#include "gefran.h"

bool open_interfeice(char** can)
{
  struct ifreq ifr;
  struct sockaddr_can gefran_socket;
  
  status = socket(PF_CAN, SOCK_RAW, CAN_RAW);

  if (status < 0)
    {
      perror("Error while opening socket");
      return -1;
    }
  strcpy(ifr.ifr_name, can);
  ioctl(status, SIOCGIFINDEX, &ifr);

  gefran_socket.can_family = AF_CAN;
  gefran_socket.can_ifindex = ifr.ifr_ifindex;

  if (bind(status, (struct sockaddr *)&gefran_socket, sizeof(gefran_socket))<0)
    {
      perror("Error socket bind");
      return -1;
    }

   return true;
}

_position_hex* give_value_position(void)
{
  position_hex *gefran_hex_result;

  gefran_hex = &gefran_can_frame;
  
  gefran_hex_result = (position_hex*)malloc(sizeof(position_hex));
  if (!gefran_hex_result){
    perror("Error create memmory\n");
    return -1;
  }
  
  uint8_t status_read = read(status, &gefran_can_frame, sizeof(struct can_frame));
  if (status_read == -1){
    perror("Error read CAN message\n");
    return -1;
  }
  /*Принимаю байты и записываю их отдельно для того чтобы объединить */
  gefran_hex_result->byte1 = (gefran_can_frame.data[1]<<8)+gefran_can_frame.data[0];
  gefran_hex_result->byte2 = (gefran_can_frame.data[3]<<8)+gefran_can_frame.data[2];

  
  if (gefran_hex_result->byte1 > 32768){
    gefran_hex_result->X_hex_result = gefran_hex_result->byte1 - 65536;
    printf ("Position: %d\t", gefran_hex_result->X_hex_result);
  }
  else{
    gefran_hex_result->X_hex_result = gefran_hex_result->byte1;
    printf ("Position: %d\t", gefran_hex_result->X_hex_result);
  }
  
  if (gefran_hex_result->byte2 > 32768){
    gefran_hex_result->Y_hex_result = gefran_hex_result->byte2 - 65536;
    printf ("%d\n", gefran_hex_result->Y_hex_result);
  }
  else{
    gefran_hex_result->Y_hex_result = gefran_hex_result->byte2;
    printf ("%d\n", gefran_hex_result->Y_hex_result);
  }

  return gefran_hex_result;
  
  free(gefran_hex_result);
}
